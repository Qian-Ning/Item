#### vue

1. `v-if`与`v-show`的区别

`v-if`和`v-show`都是Vue中常用的指令，用于控制元素的显示和隐藏。它们的区别在于：

* `v-if`：通过添加或移除DOM元素来控制元素的显示和隐藏。当`v-if`的表达式为`false`时，会从DOM中移除对应的元素，当表达式为`true`时，会将元素添加到DOM中。
* `v-show`：通过修改元素的CSS样式（`display`属性）来控制元素的显示和隐藏。当`v-show`的表达式为`false`时，会将元素的`display`属性设置为`none`，隐藏元素，当表达式为`true`时，会将元素的`display`属性设置为``（空字符串），显示元素。

总结：当需要频繁切换元素的显示和隐藏时，推荐使用`v-show`，因为它只改变元素的CSS样式，而不涉及DOM操作，性能更好。当元素的显示和隐藏不频繁切换时，推荐使用`v-if`，因为它可以减少不必要的DOM操作。

2. vant移动端适配怎么做到自动

Vant是一个基于Vue的移动端UI组件库，它提供了一些组件和工具类，可以帮助开发者快速构建移动端页面。Vant的自动适配主要是通过响应式设计实现的。

* 使用媒体查询：Vant的样式中使用了媒体查询，可以根据不同的设备屏幕宽度适配不同的样式。例如，当屏幕宽度小于750px时，Vant会自动切换到小屏模式。
* 使用flex布局：Vant的组件样式中使用了flex布局，可以自适应不同屏幕尺寸和设备方向。
* 使用vw/vh单位：Vant的样式中使用了视口宽度单位（vw）和视口高度单位（vh），可以根据屏幕宽度和高度自动适配样式。

3. axios拦截器有哪些

Axios是一个常用的基于Promise的HTTP库，可以用于浏览器和Node.js。Axios提供了请求和响应拦截器功能，可以在请求发送前或响应返回后进行一些处理。Axios拦截器有以下几种：

* 请求拦截器：在请求发送前进行一些处理，例如添加请求头、进行参数校验等。
* 响应拦截器：在响应返回后进行一些处理，例如处理异常、进行数据转换等。
* 错误拦截器：在请求发生错误时进行一些处理，例如提示错误信息、进行重试等。
* 取消拦截器：在请求被取消时进行一些处理，例如提示用户请求被取消。

4. 在拦截器中，一般做些什么

在Axios拦截器中，一般可以进行以下操作：

* 添加请求头：在请求拦截器中可以添加一些公共的请求头信息，例如token、用户信息等。
* 参数校验：在请求拦截器中可以对请求参数进行一些校验，例如检查参数是否合法、是否必填等。
* 数据转换：在响应拦截器中可以对返回的数据进行一些处理，例如将JSON字符串转换为JavaScript对象、将日期字符串转换为Date对象等。
* 异常处理：在响应拦截器中可以处理一些异常情况，例如请求超时、网络错误等。
* 提示错误信息：在错误拦截器中可以提示用户错误信息，例如请求被取消、请求发生错误等。
* 重试操作：在错误拦截器中可以进行重试操作，例如当请求发生错误时可以自动重试。

5. 在使用计算属性的时，函数名和data数据源中的数据可以同名吗，为什么？

在使用Vue的计算属性时，函数名和data数据源中的数据可以同名。这是因为计算属性是基于data数据源中的数据通过计算得到的，它们之间的关系是单向的。即使函数名和data数据源中的数据同名，也不会产生冲突。当data数据源中的数据发生变化时，计算属性会自动重新计算。因此，在使用计算属性时，可以根据需要自由命名函数名和data数据源中的数据。

#### js

1. 什么是防抖,举一个例子

防抖（debounce）是指在一定时间内只触发一次事件的处理方式。它可以减少事件处理函数的执行频率，提高性能。防抖的原理是在事件触发后的一段时间内，如果再次触发该事件，则会取消之前的延时调用，重新开始计时，直到超过指定的时间后才执行事件处理函数。

举一个例子：输入框实时搜索。用户在输入框输入文字时，只有当用户停止输入一段时间后，才去执行事件处理函数（发送搜索请求）。如果用户在输入过程中连续输入文字，则会取消之前的延时调用，重新开始计时。这样可以减少不必要的搜索请求次数，提高性能。

实现防抖的方法可以使用setTimeout和clearTimeout来实现。当事件触发时，使用setTimeout设置一个延时调用事件处理函数，并给这个延时调用设置一个唯一的id。在事件触发后的一段时间内，如果再次触发该事件，则使用clearTimeout取消之前的延时调用。当超过指定的时间后，执行事件处理函数。

2. 什么是节流,举一个例子

节流（throttle）是指在一定时间内只执行一次事件处理函数的方式。它可以减少事件处理函数的执行频率，提高性能。节流的原理是在事件触发后的一段时间内，如果再次触发该事件，则会忽略这次事件，直到超过指定的时间后才执行事件处理函数。

举一个例子：滚动加载更多内容。当用户滚动页面时，只有当用户停止滚动一段时间后，才去执行事件处理函数（加载更多内容）。如果用户在滚动过程中连续滚动页面，则会忽略这次事件，重新开始计时。这样可以减少不必要的加载请求次数，提高性能。

实现节流的方法可以使用setTimeout和clearTimeout来实现。当事件触发时，使用setTimeout设置一个延时调用事件处理函数，并给这个延时调用设置一个唯一的id。在事件触发后的一段时间内，如果再次触发该事件，则使用clearTimeout取消之前的延时调用。当超过指定的时间后，执行事件处理函数。

3. 写出4种js的设计模式

* 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
* 工厂模式（Factory）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。
* 观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
* 模块模式（Module）：将单个对象封装在一个自包含的函数中，然后在需要的时候引用这个函数。这种模式可以用来创建有状态的单例对象或者用来封装一些工具方法。

#### css

1. display:none和visibility:hidden两者的区别

`display: none;` 和 `visibility: hidden;` 都可以用来隐藏元素，但它们有一些区别：

* `display: none;` 会将元素从文档流中完全移除，不占据任何空间，就像它从未存在过一样。同时，它的子元素也会被隐藏并且不会触发任何绑定的事件。此外，它的过渡效果不会生效。

* `visibility: hidden;` 会使元素隐藏但是仍占据其在文档流中的空间。它的子元素也会被隐藏但是仍然可以触发绑定的事件。此外，它的过渡效果会生效。

  
2. flex中的属性有哪些

Flex布局是一种现代的CSS布局方式，它提供了以下属性：

* flex-direction：决定主轴的方向（即项目的排列方向）。主要有四个值：row（默认值）、row-reverse、column、column-reverse。

* flex-wrap：默认情况下，项目都排在一条线上。flex-wrap属性定义项目是否换行。主要有三个值：nowrap（默认值）、wrap、wrap-reverse。

* flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

* justify-content：定义了项目在主轴上的对齐方式。主要有五个值：flex-start（默认值）、flex-end、center、space-between、space-around。

* align-items：定义项目在交叉轴上如何对齐。主要有五个值：stretch（默认值）、flex-start、flex-end、center、baseline。

* align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。主要有六个值：stretch（默认值）、flex-start、flex-end、center、space-between、space-around。

  
3. 水平垂直居中3种方式

   在CSS中，有三种实现水平垂直居中的方式：

   1. 使用flexbox布局：将元素的父元素设置为flexbox布局，然后使用justify-content和align-items属性来分别控制水平和垂直方向的对齐方式。例如：
   ```css
   .parent {
     display: flex;
     justify-content: center; /* 水平居中 */
     align-items: center; /* 垂直居中 */
   }
   ```
   2. 使用grid布局：将元素的父元素设置为grid布局，然后使用place-items属性来控制水平和垂直居中。例如：
   ```css
   .parent {
     display: grid;
     place-items: center;
   }
   ```
   3. 使用position属性：将元素的父元素设置为相对定位，然后将元素设置为绝对定位，并使用left和top属性将元素移动到父元素的中心。例如：
   ```css
   .father {
     position: relative;
   }
   .son {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
   }
   ```
